/*
BEGIN__TT_COMPUTE_SHADER_HEADER

Language HLSL
LanguageVersion 2018

TTComputeType General

END__TT_COMPUTE_SHADER_HEADER
*/

cbuffer gv
{
    uint2 TransTargetMapSize;
    uint2 TransSourceMapSize;
    float MaxDistance;
    float alimentPadding1;
    float alimentPadding2;
    float alimentPadding3;
}

RWTexture2D<float2> TransMap;
RWTexture2D<float2> DistanceAndScaling; // MaxDistance の値を先に書き込んで初期化しておく必要がある。

StructuredBuffer<float4> Polygons; // 頂点が、三つずつ並んでいて from が xy 、 to が zw にパッキングされている想定。 0~1 の正規化された空間を想定。

float TriangleArea(float2 tri[3])
{
    float a = cross(float3(tri[1] - tri[0], 0), float3(tri[2] - tri[0], 0)).z;
    return a;
}
float3 Barycentric(float2 tri[3], float2 p)
{
    float u = cross(float3(tri[2] - tri[1], 0), float3(p - tri[1], 0)).z;
    float v = cross(float3(tri[0] - tri[2], 0), float3(p - tri[2], 0)).z;
    float w = cross(float3(tri[1] - tri[0], 0), float3(p - tri[0], 0)).z;
    float a = TriangleArea(tri);
    return float3(u, v, w) / a;
}
float2 CalculatePositionFromBarycentric(float2 tri[3], float3 bc)
{
    float2 pos = float2(0, 0);
    pos += tri[0] * bc.x;
    pos += tri[1] * bc.y;
    pos += tri[2] * bc.z;
    return pos;
}
float2 Line2Near(float2 v1, float2 v2, float2 p)
{
    float2 vLine = v2 - v1;
    float vLength = length(vLine);
    float2 vLineNormalized = normalize(vLine);
    float onLineLength = clamp(dot(vLineNormalized, p - v1), 0, vLength);
    return v1 + (vLineNormalized * onLineLength);
}
float Distance(float2 tri[3], float2 p)
{
    float2 np0 = Line2Near(tri[0], tri[1], p) - p;
    float2 np1 = Line2Near(tri[1], tri[2], p) - p;
    float2 np2 = Line2Near(tri[2], tri[0], p) - p;

    float npl0 = np0.x * np0.x + np0.y * np0.y;
    float npl1 = np1.x * np1.x + np1.y * np1.y;
    float npl2 = np2.x * np2.x + np2.y * np2.y;
    return sqrt(min(min(npl0, npl1), npl2));
}

float InsideBarycentric(float3 bc)
{
    float v = 0;
    v += bc.x >= 0 ? 1 : -1;
    v += bc.y >= 0 ? 1 : -1;
    v += bc.z >= 0 ? 1 : -1;
    return ceil(saturate(abs(v) - 2.5));
}
float4 MinMax(float2 tri[3])
{
    float2 minVal = min(min(tri[0], tri[1]), tri[2]);
    float2 maxVal = max(max(tri[0], tri[1]), tri[2]);
    return float4(minVal - MaxDistance, maxVal + MaxDistance);
}
#define PARALLEL_COUNT 256
// #define PARALLEL_COUNT 1
[numthreads(1, PARALLEL_COUNT, 1)] void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint thisID = id.y;
    uint idMax = PARALLEL_COUNT;
    uint polygonIndex = id.x * 3;

    float2 fromPolygonWithNormalizeScale[3];
    float2 fromPolygon[3];
    float2 toPolygon[3];
    fromPolygonWithNormalizeScale[0].xy = Polygons[polygonIndex + 0].xy;
    fromPolygonWithNormalizeScale[1].xy = Polygons[polygonIndex + 1].xy;
    fromPolygonWithNormalizeScale[2].xy = Polygons[polygonIndex + 2].xy;
    fromPolygon[0].xy = Polygons[polygonIndex + 0].xy * float2(TransSourceMapSize);
    fromPolygon[1].xy = Polygons[polygonIndex + 1].xy * float2(TransSourceMapSize);
    fromPolygon[2].xy = Polygons[polygonIndex + 2].xy * float2(TransSourceMapSize);

    toPolygon[0].xy = Polygons[polygonIndex + 0].zw * float2(TransTargetMapSize);
    toPolygon[1].xy = Polygons[polygonIndex + 1].zw * float2(TransTargetMapSize);
    toPolygon[2].xy = Polygons[polygonIndex + 2].zw * float2(TransTargetMapSize);

    float4 rect = MinMax(toPolygon);
    int2 minVal = int2(floor(rect.xy));
    int2 maxVal = int2(ceil(rect.zw));

    int ySize = maxVal.y - minVal.y;
    for (int yID = thisID; ySize > yID; yID += idMax)
    {
        int y = minVal.y + yID;
        for (int x = minVal.x; maxVal.x > x; x += 1)
        {
            float2 pos = float2(x + 0.5, y + 0.5);
            int2 posIndex = int2(x, y);

            float fromArea = TriangleArea(fromPolygon) / 2;
            float toArea = TriangleArea(toPolygon) / 2;
            float scaling = clamp( abs(fromArea / toArea),0 ,64);// safety

            float3 toBC = Barycentric(toPolygon, pos);
            float distance = Distance(toPolygon, pos);
            if (InsideBarycentric(toBC) > 0.5)
            {
                distance = -1;
            }

            float2 transSourcePos = CalculatePositionFromBarycentric(fromPolygonWithNormalizeScale, toBC);

            bool isWrite = DistanceAndScaling[posIndex].x > distance && MaxDistance > distance;

            if (isWrite)
            {
                DistanceAndScaling[posIndex] = float2(distance, scaling);
                TransMap[posIndex] = transSourcePos;
            }
        }
    }

}
