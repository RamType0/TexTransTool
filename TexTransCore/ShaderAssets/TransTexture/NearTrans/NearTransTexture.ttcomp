/*
BEGIN__TT_COMPUTE_SHADER_HEADER

Language HLSL
LanguageVersion 2018

TTComputeType General

END__TT_COMPUTE_SHADER_HEADER
*/

cbuffer gv
{
    uint2 PositionMapSize;
    float MaxDistance;

    float AlimentPadding1;


    uint PolygonStartIndex;
    uint PolygonCount;

    float AlimentPadding2;
    float AlimentPadding3;
}
// PointMap でもあるわね
RWStructuredBuffer<float4> PositionDistanceMap; // XYZ + Distance(W)
// 一番近い場所から UV 情報にし、後にテクスチャとして書きこむ形をとります。

// 書き込まれる対象。 Polygon To Distance は初期化されていなくても問題はない。
RWTexture2D<float2> TransMap;
RWTexture2D<float> PolygonToDistance;// ポイントと一番近いポリゴンへの距離がどれだけあったかのマップ

// これらは、コピー元のポリゴン Vertex が座標 UVVertex がテクスチャの取得場所
StructuredBuffer<int> PolygonIndex;
StructuredBuffer<float4> Vertex;
StructuredBuffer<float2> UVVertex;

#include "../TransTexture/TransMappingHelper.hlsl"

struct Plane
{
    float3 normal;
};

struct NearPlanePoint
{
    float3 position;
    float distance;
};

Plane PolygonToPlane(float3 polygon[3])
{
    float3 planeNormal = normalize( cross( polygon[1] - polygon[0] , polygon[2] - polygon[0] ) );
    Plane plane;
    plane.normal = planeNormal;
    return plane;
}
NearPlanePoint ClosetPointOnPlane(float3 p, float3 polygon[3], Plane polygonPlane)
{
    float3 polygonToPoint = p - polygon[0];
    float planeToDistance = dot(polygonPlane.normal , polygonToPoint);
    float3 onPoint = p - (polygonPlane.normal * planeToDistance);

    NearPlanePoint result;
    result.position = onPoint;
    result.distance = abs( planeToDistance );
    return result;
}
float3 Barycentric(float3 p, float3 tri[3], Plane polygonPlane)
{
    float3 pTri[3];

    pTri[0] = tri[0] - p;
    pTri[1] = tri[1] - p;
    pTri[2] = tri[2] - p;

    float u = dot( cross(pTri[2], pTri[1]) , polygonPlane.normal );
    float v = dot( cross(pTri[2], pTri[0]) , polygonPlane.normal );
    float w = dot( cross(pTri[0], pTri[1]) , polygonPlane.normal );
    float3 bc = float3(u,v,w) / (u+v+w);

    return float3(bc);
}
[numthreads(32, 32, 1)] void CSMain(uint3 id : SV_DispatchThreadID)
{
    float3 fPoint = PositionDistanceMap[(PositionMapSize.x * id.y) + id.x].xyz;

    float2 transSourcePos;
    float polygonToDistance = MaxDistance + 0.01;

    for (uint pi = PolygonStartIndex; PolygonCount > pi ; pi += 1)
    {
        uint polygonIndex = pi * 3;

        float3 polygon[3];
        polygon[0].xyz = Vertex[PolygonIndex[polygonIndex + 0]].xyz;
        polygon[1].xyz = Vertex[PolygonIndex[polygonIndex + 1]].xyz;
        polygon[2].xyz = Vertex[PolygonIndex[polygonIndex + 2]].xyz;
        float2 uvPolygon[3];
        uvPolygon[0] = UVVertex[PolygonIndex[polygonIndex + 0]];
        uvPolygon[1] = UVVertex[PolygonIndex[polygonIndex + 1]];
        uvPolygon[2] = UVVertex[PolygonIndex[polygonIndex + 2]];


        // 最接近点が polygon の上だった場合
        Plane plane = PolygonToPlane(polygon);
        NearPlanePoint planePoint = ClosetPointOnPlane(fPoint , polygon , plane);
        float3 bc = Barycentric(fPoint , polygon , plane);

        if( InsideBarycentric( bc ) )
        {
            // それが他よりも近かったらそのまま書き込む。
            if(polygonToDistance < planePoint.distance) { continue; }
            transSourcePos = CalculatePositionFromBarycentric(uvPolygon, bc);
            polygonToDistance = planePoint.distance;

            continue;
        }

        // 外だった場合 polygon の辺の上で一番近いところをだす。(同時に一番近いところが頂点であった場合も。)

        float3 lNear0 = Line2NearWthFloat3(polygon[0], polygon[1], fPoint);
        float3 lNear1 = Line2NearWthFloat3(polygon[1], polygon[2], fPoint);
        float3 lNear2 = Line2NearWthFloat3(polygon[2], polygon[0], fPoint);
        float lDistance0 = distance(lNear0 , fPoint);
        float lDistance1 = distance(lNear1 , fPoint);
        float lDistance2 = distance(lNear2 , fPoint);

        float minLength = min(min(lDistance0 , lDistance1) , lDistance2);

        if( polygonToDistance < minLength ) { continue; }

        float3 lineOnNearPoint;
        if ( minLength == lDistance0 ){ lineOnNearPoint = lNear0;}
        else if ( minLength == lDistance1 ){ lineOnNearPoint = lNear1;}
        else { lineOnNearPoint = lNear2;}

        bc = Barycentric(lineOnNearPoint , polygon , plane);

        transSourcePos = CalculatePositionFromBarycentric(uvPolygon, bc);
        polygonToDistance = minLength;
    }

    TransMap[id.xy] = transSourcePos;
    PolygonToDistance[id.xy] = polygonToDistance;
}

