/*
BEGIN__TT_COMPUTE_SHADER_HEADER

Language HLSL
LanguageVersion 2018

TTComputeType General

END__TT_COMPUTE_SHADER_HEADER
*/

#include "./TransMappingStorages.hlsl"
#include "./TransMappingHelper.hlsl"

[numthreads(32, 32, 1)] void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint polygonIndex = id.z * 3;

    float2 fromPolygonWithNormalizeScale[3];
    float2 fromPolygon[3];
    float2 fromPolygonAdditionalData[3];
    float2 toPolygon[3];
    fromPolygonWithNormalizeScale[0].xy = FromPolygons[polygonIndex + 0].xy;
    fromPolygonWithNormalizeScale[1].xy = FromPolygons[polygonIndex + 1].xy;
    fromPolygonWithNormalizeScale[2].xy = FromPolygons[polygonIndex + 2].xy;
    fromPolygon[0].xy = FromPolygons[polygonIndex + 0].xy * float2(TransSourceMapSize);
    fromPolygon[1].xy = FromPolygons[polygonIndex + 1].xy * float2(TransSourceMapSize);
    fromPolygon[2].xy = FromPolygons[polygonIndex + 2].xy * float2(TransSourceMapSize);
    fromPolygonAdditionalData[0].xy = FromPolygons[polygonIndex + 0].zw;
    fromPolygonAdditionalData[1].xy = FromPolygons[polygonIndex + 1].zw;
    fromPolygonAdditionalData[2].xy = FromPolygons[polygonIndex + 2].zw;

    toPolygon[0].xy = ToPolygons[polygonIndex + 0].xy * float2(TransTargetMapSize);
    toPolygon[1].xy = ToPolygons[polygonIndex + 1].xy * float2(TransTargetMapSize);
    toPolygon[2].xy = ToPolygons[polygonIndex + 2].xy * float2(TransTargetMapSize);


    float2 pos = float2(id.x + 0.5, id.y + 0.5);
    uint2 posIndex = id.xy;


    float fromArea = abs( TriangleArea(fromPolygon) / 2 );
    float toArea = abs( TriangleArea(toPolygon) / 2 );
    float scaling = clamp(fromArea / toArea,0 ,64);// safety

    if(toArea <= 0.00001){return;} // Nan が生成されるような 面積の存在しない triangle を回避する

    float3 toBC = Barycentric(toPolygon, pos);
    float distance = Distance(toPolygon, pos);
    if (InsideBarycentric(toBC) > 0.5)
    {
        distance = -1;
    }

    float2 transSourcePos = CalculatePositionFromBarycentric(fromPolygonWithNormalizeScale, toBC);
    float2 additionalData = CalculatePositionFromBarycentric(fromPolygonAdditionalData, toBC);

    bool isWrite = DistanceMap[posIndex] > distance && MaxDistance > distance;

    if (isWrite)
    {
        DistanceMap[posIndex] = distance;
        ScalingMap[posIndex] = scaling;
        TransMap[posIndex] = transSourcePos;
        AdditionalDataMap[posIndex]= additionalData;
    }

}
