/*
BEGIN__TT_COMPUTE_SHADER_HEADER

Language HLSL
LanguageVersion 2018

TTComputeType General

END__TT_COMPUTE_SHADER_HEADER
*/

#include "./TransMappingStorages.hlsl"
#include "./TransMappingHelper.hlsl"

float4 MinMax(float2 tri[3])
{
    float2 minVal = min(min(tri[0], tri[1]), tri[2]);
    float2 maxVal = max(max(tri[0], tri[1]), tri[2]);
    return float4(minVal - MaxDistance, maxVal + MaxDistance);
}
#define PARALLEL_COUNT 256
// #define PARALLEL_COUNT 1
[numthreads(1, PARALLEL_COUNT, 1)] void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint thisID = id.y;
    uint idMax = PARALLEL_COUNT;
    uint polygonIndex = id.x * 3;

    float2 fromPolygonWithNormalizeScale[3];
    float2 fromPolygon[3];
    float2 fromPolygonAdditionalData[3];
    float2 toPolygon[3];
    fromPolygonWithNormalizeScale[0].xy = FromPolygons[polygonIndex + 0].xy;
    fromPolygonWithNormalizeScale[1].xy = FromPolygons[polygonIndex + 1].xy;
    fromPolygonWithNormalizeScale[2].xy = FromPolygons[polygonIndex + 2].xy;
    fromPolygon[0].xy = FromPolygons[polygonIndex + 0].xy * float2(TransSourceMapSize);
    fromPolygon[1].xy = FromPolygons[polygonIndex + 1].xy * float2(TransSourceMapSize);
    fromPolygon[2].xy = FromPolygons[polygonIndex + 2].xy * float2(TransSourceMapSize);
    fromPolygonAdditionalData[0].xy = FromPolygons[polygonIndex + 0].zw;
    fromPolygonAdditionalData[1].xy = FromPolygons[polygonIndex + 1].zw;
    fromPolygonAdditionalData[2].xy = FromPolygons[polygonIndex + 2].zw;


    toPolygon[0].xy = ToPolygons[polygonIndex + 0].xy * float2(TransTargetMapSize);
    toPolygon[1].xy = ToPolygons[polygonIndex + 1].xy * float2(TransTargetMapSize);
    toPolygon[2].xy = ToPolygons[polygonIndex + 2].xy * float2(TransTargetMapSize);

    float4 rect = MinMax(toPolygon);
    int2 minVal = int2(floor(rect.xy));
    int2 maxVal = int2(ceil(rect.zw));

    int ySize = maxVal.y - minVal.y;
    for (int yID = thisID; ySize > yID; yID += idMax)
    {
        int y = minVal.y + yID;
        for (int x = minVal.x; maxVal.x > x; x += 1)
        {
            float2 pos = float2(x + 0.5, y + 0.5);
            int2 posIndex = int2(x, y);

            float fromArea = abs( TriangleArea(fromPolygon) / 2 );
            float toArea = abs( TriangleArea(toPolygon) / 2 );
            float scaling = clamp( fromArea / toArea ,0 ,64);// safety

            if(toArea <= 0.00001){return;} // Nan が生成されるような 面積の存在しない triangle を回避する

            float3 toBC = Barycentric(toPolygon, pos);
            float distance = Distance(toPolygon, pos);
            if (InsideBarycentric(toBC) > 0.5)
            {
                distance = -1;
            }

            float2 transSourcePos = CalculatePositionFromBarycentric(fromPolygonWithNormalizeScale, toBC);
            float2 additionalData = CalculatePositionFromBarycentric(fromPolygonAdditionalData, toBC);

            bool isWrite = DistanceMap[posIndex] > distance && MaxDistance > distance;

            if (isWrite)
            {
                DistanceMap[posIndex] = distance;
                ScalingMap[posIndex] = scaling;
                TransMap[posIndex] = transSourcePos;
                AdditionalDataMap[posIndex]= additionalData;
            }
        }
    }

}
